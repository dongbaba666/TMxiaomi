### 函数
- 普通函数
    运行函数中的代码，为了复用

- 构造函数(class)
    this实例
    默认return 实例
    在类里面一般都是添加属性

    new 构造函数

- 原型和原型链：
    函数走原型 (构造函数的实例)

    实例走原型链 (实例找不到某个属性或者方法就走原型链)

    实例的原型链 === 构造函数的原型

# 重写new
- call(that，多个参数)
- apply(that，两个参数)
- bind(that，多个参数)

    共同特点
        第一个参数都是改变this指向的，函数自带的

        在使用它们修改this的时候，不要传null和undefined，因为传了也不认还是走默认的window

    1.this是实例
    2.默认return实例，如果return为引用类型为引用类型
    3.实力的原型链 === 构造函数的原型
    4.可以不加括号调用


## class 类名
- constructor 给自身添加属性或者方法，就必须要写constructor

- 如果使用类那么不能直接修改类的原型地址


## call
- 所有的数据都有一个toString的方法，但是写法是不一样的
- 唯独Object的toString能够去检测当前的数据类型，所以可以把this改变，达到目的
- Array的toString，除了数组本身别的也都能检测数据类型
- Array.from() 把类数组转数组
- slice返回一个新的数组，不传参就是把整个数组返回

## 解构赋值
- 数组的解构赋值：
    声明的时候一定要是个数组，左右两边的结构保持一致

    // 报错
            let [foo] = 1;
            let [foo] = false;
            let [foo] = NaN;
            let [foo] = undefined;
            let [foo] = null;
            let [foo] = {};


### 对象的结构赋值
- 在声明的时候使用块声明，块中放对象的key值，这里的key值一定要和解构对象的key值名字要一致

- 如果要取别名，使用“:”新定义的名字即可
    let {key:k,key2} = {key1:vall,key2:val2}

    此时key1已经访问不到了，要访问就报错，只能访问k，k就代表key1

    名字跟声明变量规则一致

    如果加了：不报错，那么可以先解构一次，在重命名

- 传了对象那么就按照传的对象来解析，不会按照默认的来解析